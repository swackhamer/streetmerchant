/**
 * Script to analyze store files and generate registry entries
 */
const fs = require('fs');
const path = require('path');
const prettier = require('prettier');

const storeDir = path.join(__dirname, '../src/store/model');
const outputFile = path.join(__dirname, '../src/store/model/generated-registry.ts');

// List all store files in the directory
const storeFiles = fs.readdirSync(storeDir)
  .filter(file => file.endsWith('.ts'))
  .filter(file => {
    // Exclude utility files and non-store files
    return !file.includes('store.ts') &&
           !file.includes('index.ts') &&
           !file.includes('sample-') &&
           !file.includes('series-') &&
           !file.includes('auto-load-') &&
           !file.includes('link-validator') &&
           !file.includes('store-registry') &&
           !file.includes('timestamp-');
  });

console.log(`Found ${storeFiles.length} store files to process.`);

// Common patterns to look for
const countryPattern = /country:\s*['"]([A-Z]{2})['"],/;
const currencyPattern = /currency:\s*['"]([£$€R$kr.])['"],/;
const labelsPattern = /labels:\s*({[\s\S]*?}),\s*(\/\/|[a-zA-Z])/;
const inStockPattern = /inStock:[\s\S]*?container:\s*['"]([^'"]+)['"],[\s\S]*?text:\s*(\[[^\]]*\]|\{[^}]*\})/;
const outOfStockPattern = /outOfStock:[\s\S]*?container:\s*['"]([^'"]+)['"],[\s\S]*?text:\s*(\[[^\]]*\]|\{[^}]*\})/;
const maxPricePattern = /maxPrice:[\s\S]*?container:\s*['"]([^'"]+)['"],[\s\S]*?euroFormat:\s*(true|false)/;

// Function to determine store type
function determineStoreType(content, country) {
  if (content.includes('marketplace') || 
      content.includes('bannedSeller') || 
      content.includes('third-party')) {
    return 'marketplace';
  }
  
  if (['DE', 'FR', 'IT', 'ES', 'NL', 'BE', 'AT', 'DK', 'SE', 'NO', 'FI'].includes(country)) {
    return 'european';
  }
  
  return 'standard';
}

// Function to extract labels
function extractLabels(content) {
  const labels = {};
  
  // Check for inStock
  const inStockMatch = content.match(inStockPattern);
  if (inStockMatch) {
    labels.inStock = {
      container: inStockMatch[1],
      text: JSON.parse(inStockMatch[2].replace(/'/g, '"'))
    };
  }
  
  // Check for outOfStock
  const outOfStockMatch = content.match(outOfStockPattern);
  if (outOfStockMatch) {
    labels.outOfStock = {
      container: outOfStockMatch[1],
      text: JSON.parse(outOfStockMatch[2].replace(/'/g, '"'))
    };
  }
  
  // Check for maxPrice
  const maxPriceMatch = content.match(maxPricePattern);
  if (maxPriceMatch) {
    labels.maxPrice = {
      container: maxPriceMatch[1],
      euroFormat: maxPriceMatch[2] === 'true'
    };
  }
  
  return labels;
}

// Process each store file and generate registry entries
const registryEntries = [];

storeFiles.forEach(file => {
  const storeName = file.replace('.ts', '');
  const filePath = path.join(storeDir, file);
  const content = fs.readFileSync(filePath, 'utf8');
  
  let country = 'US'; // Default
  const countryMatch = content.match(countryPattern);
  if (countryMatch) {
    country = countryMatch[1];
  }
  
  let currency = '$'; // Default
  const currencyMatch = content.match(currencyPattern);
  if (currencyMatch) {
    currency = currencyMatch[1];
  }
  
  const storeType = determineStoreType(content, country);
  
  // Extract labels if possible
  let labels = {};
  const labelsMatch = content.match(labelsPattern);
  if (labelsMatch) {
    try {
      labels = extractLabels(content);
    } catch (error) {
      console.warn(`Warning: Could not parse labels for ${storeName}`);
    }
  }
  
  // Create registry entry
  const entry = {
    name: storeName,
    country,
    currency,
    storeType,
    labels
  };
  
  // Check for special configuration values
  if (content.includes('minPageSleep')) {
    const minPageSleepMatch = content.match(/minPageSleep:\s*(\d+)/);
    if (minPageSleepMatch) {
      entry.minPageSleep = parseInt(minPageSleepMatch[1], 10);
    }
  }
  
  if (content.includes('maxPageSleep')) {
    const maxPageSleepMatch = content.match(/maxPageSleep:\s*(\d+)/);
    if (maxPageSleepMatch) {
      entry.maxPageSleep = parseInt(maxPageSleepMatch[1], 10);
    }
  }
  
  if (content.includes('disableAdBlocker')) {
    entry.disableAdBlocker = true;
  }
  
  registryEntries.push(entry);
});

// Generate the registry file
let registryString = '/**\n * Generated Store Registry\n * This file is auto-generated by scripts/generate-store-registry.js\n */\n\n';
registryString += 'import {ExtendedStoreOptions} from \'./store-registry\';\n\n';
registryString += '/**\n * Generated registry entries for all stores\n */\n';
registryString += 'export const generatedStoreRegistry: Record<string, ExtendedStoreOptions> = {\n';

registryEntries.forEach(entry => {
  registryString += `  '${entry.name}': {\n`;
  registryString += `    name: '${entry.name}',\n`;
  registryString += `    country: '${entry.country}',\n`;
  registryString += `    currency: '${entry.currency}',\n`;
  registryString += `    storeType: '${entry.storeType}',\n`;
  
  // Add labels
  if (Object.keys(entry.labels).length > 0) {
    registryString += '    labels: {\n';
    
    if (entry.labels.inStock) {
      registryString += '      inStock: {\n';
      registryString += `        container: '${entry.labels.inStock.container}',\n`;
      registryString += `        text: ${JSON.stringify(entry.labels.inStock.text)}\n`;
      registryString += '      },\n';
    }
    
    if (entry.labels.outOfStock) {
      registryString += '      outOfStock: {\n';
      registryString += `        container: '${entry.labels.outOfStock.container}',\n`;
      registryString += `        text: ${JSON.stringify(entry.labels.outOfStock.text)}\n`;
      registryString += '      },\n';
    }
    
    if (entry.labels.maxPrice) {
      registryString += '      maxPrice: {\n';
      registryString += `        container: '${entry.labels.maxPrice.container}',\n`;
      registryString += `        euroFormat: ${entry.labels.maxPrice.euroFormat}\n`;
      registryString += '      }\n';
    }
    
    registryString += '    }\n';
  } else {
    registryString += '    labels: {}\n';
  }
  
  // Add additional properties
  if (entry.minPageSleep !== undefined) {
    registryString += `    minPageSleep: ${entry.minPageSleep},\n`;
  }
  
  if (entry.maxPageSleep !== undefined) {
    registryString += `    maxPageSleep: ${entry.maxPageSleep},\n`;
  }
  
  if (entry.disableAdBlocker) {
    registryString += '    disableAdBlocker: true,\n';
  }
  
  registryString += '  },\n';
});

registryString += '};\n';

// Format the output with prettier
prettier.resolveConfig(outputFile).then(options => {
  const formatted = prettier.format(registryString, { 
    ...options, 
    parser: 'typescript' 
  });
  
  fs.writeFileSync(outputFile, formatted);
  console.log(`Generated registry with ${registryEntries.length} store entries.`);
});